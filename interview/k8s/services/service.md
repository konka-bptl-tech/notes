# Why we using services in k8s?

In Kubernetes, we use **services** mainly because **pods are ephemeral**—their IP addresses keep changing whenever a pod restarts, scales, or gets recreated due to configuration changes. Since pod IPs are not stable, we cannot rely on them for internal communication. To solve this, Kubernetes provides a **Service** resource, which offers a **stable IP or DNS name** to access a group of pods. Services work independently of pod lifecycles and use **labels and selectors** to automatically identify and route traffic to the correct pods. Behind the scenes, the **EndpointSlice controller** keeps track of all healthy pod IPs—adding new ones and removing deleted ones.

The two main features of Kubernetes services are **service discovery** and **load balancing**. Service discovery allows other components to access services using DNS names instead of IPs. Load balancing helps distribute traffic evenly across all available pods. Kubernetes supports different types of services like **ClusterIP**, **NodePort**, **LoadBalancer**, and **ExternalName**. ClusterIP is the default type and exposes services only within the cluster. NodePort exposes a service externally using a fixed port on each node but is less secure and rarely used in production. LoadBalancer is used in cloud environments to expose services externally through a cloud provider's load balancer. ExternalName maps a Kubernetes service to an external DNS name (CNAME), allowing access to external services from inside the cluster.

When a LoadBalancer service is created, Kubernetes also sets up a NodePort and ClusterIP behind it. Similarly, creating a NodePort service also creates a ClusterIP. The internal access flow for a LoadBalancer service is: LoadBalancer IP → NodeIP\:NodePort → ClusterIP\:ClusterPort → PodIP\:Port. This layered routing ensures stability and flexibility in accessing applications within and outside the cluster.

# EKS IP Exhaustion[https://www.youtube.com/watch?v=ICgj71wmN6E]

